while (enumerator.MoveNext()  )
                {
                    
                    // Adjusting JobTypeID if it has an invalid text format
                    if (enumerator.Current.Contains('J') && !enumerator.Current[0].Equals('J'))
                    {
                        LogWarning($"Invalid jobTypeID: {enumerator.Current}",rowCount,columnCount);
                        
                        // Correct the invalid jobTypeID 
                        var charList = enumerator.Current.ToCharArray();
                        
                        // Adjusting the invalid jobTypeID
                        string adjustedID = "J";
                        foreach (var c in charList)
                        {
                            if (c != 'J')
                                adjustedID += c;
                        }
                        rowCount += enumerator.Current.Length + 1;
                        prevData = enumerator.Current;
                        currentJobID = adjustedID;
                        // We check the occurence of each jobTypeID . EX: if J1 occures only once and J2 occurs 2 times then we hold {J1:1, J2:2} as a Dict.
                        try
                        {
                            currentJobIDOccurance.Add(adjustedID,0);
                        }
                        catch
                        {
                            currentJobIDOccurance[adjustedID]++;
                        }
                        //Here we are trying to put jobtypeID into dictionary, if the key is already exist, then it throws an error. 
                        try
                        {
                            jobTypes.Add(adjustedID, new List<List<KeyValuePair<string, double>>>());
                            jobTypes[adjustedID].Add(new List<KeyValuePair<string, double>>());
                        }
                        //We do not need to catch error, only thing we are doing here adding another option for that jobtypeID
                        catch
                        {
                            jobTypes[adjustedID].Add(new List<KeyValuePair<string, double>>());
                        }
                        continue;
                    }
                    // If there is no problem in jobTypeID format
                    if (enumerator.Current.Contains('J') && enumerator.Current[0].Equals('J'))
                    {
                        // We check the occurence of each jobTypeID . EX: if J1 occures only once and J2 occurs 2 times then we hold {J1:0, J2:1} as a Dict.
                        try
                        {
                            currentJobIDOccurance.Add(enumerator.Current,0);
                        }
                        catch
                        {
                            currentJobIDOccurance[enumerator.Current]++;
                        } 
                        //Here we are trying to put jobtypeID into dictionary, if the key is already exist, then it throws an error.                        try
                        try
                        {
                            jobTypes.Add(enumerator.Current, new List<List<KeyValuePair<string, double>>>());
                            jobTypes[enumerator.Current].Add(new List<KeyValuePair<string, double>>());
                        }
                        //We do not need to catch error, only thing we are doing here adding another option for that jobtypeID
                        catch
                        {
                            jobTypes[enumerator.Current].Add(new List<KeyValuePair<string, double>>());
                        }

                        currentJobID = enumerator.Current;
                        rowCount += enumerator.Current.Length + 1;
                        prevData = enumerator.Current;
                        continue;
                    }
                    
                    // If taskTypeID doesn't exist in TaskTypes, we need to log the warning.
                    if (!taskTypes.Keys.Contains(prevData) && prevData.Contains('T'))
                    {
                        LogWarning($"The taskTypeID:{prevData} is not declared in TaskTypes", rowCount,columnCount);
                        rowCount += enumerator.Current.Length + 1;
                        prevData = enumerator.Current;
                        continue;
                    }

                    // If the current data is a taskTypeID, we need to add that id into sequence
                    if (enumerator.Current.Contains("T") && enumerator.Current[0].Equals('T'))
                    {
                        //Console.WriteLine($"Occurance of {currentJobID}:"+  currentJobIDOccurance[currentJobID]);
                        
                        jobTypes[currentJobID][currentJobIDOccurance[currentJobID]]
                            .Add(KeyValuePair.Create(enumerator.Current,taskTypes[enumerator.Current]));
                        
                    }
                    // if the current doesn't have 'T' and 'J', then check whether the size number is unsigned or not.
                    if (!prevData.Contains("J") && prevData.Contains('T') && !enumerator.Current.Contains('T'))
                    {
                        bool isNegative = enumerator.Current.Contains('-') && enumerator.Current[0] == '-';
                        string unsignedSize = "";
                        if (isNegative) 
                        { 
                            LogWarning($"Invalid Task Size for TaskID:{prevData} Size:{enumerator.Current}",rowCount,columnCount);
                            // Adjusting the invalid size of the current task
                            unsignedSize = enumerator.Current.Remove(0,1);
                        }
                        else
                        {
                            unsignedSize = enumerator.Current;
                        }
                        // To convert decimal data by seperated '.' correctly into a double 
                        NumberFormatInfo provider = new NumberFormatInfo();
                        provider.CurrencyDecimalSeparator = ".";
                        double size = Convert.ToDouble(unsignedSize,provider);
                        
                        // We are tyring to find in jobTypes(currentJobTypeID : [n'th option] [found index of pair.Key matched with taskTypeID])
                        // Then re-define that key-pair with {taskTypeID : size}
                        jobTypes[currentJobID][currentJobIDOccurance[currentJobID]]
                            [jobTypes[currentJobID][currentJobIDOccurance[currentJobID]]
                                .FindIndex(pair => pair.Key == prevData)] = KeyValuePair.Create(prevData,size);
                        
                        rowCount += enumerator.Current.Length + 1;
                        prevData = enumerator.Current;
                        continue;
                    }
                    
                    prevData = enumerator.Current;
                    rowCount += enumerator.Current.Length + 1;
                }
                }
            